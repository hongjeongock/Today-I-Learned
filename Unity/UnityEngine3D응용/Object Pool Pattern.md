## Q. 우리가 게임을 만들 때 무엇을 많이 하는가?

> 오브젝트 생성 / 파괴

- 생성 : Instantiate 함수
- 파괴 : Destory 함수

### 목표
1. **instantiate** 함수의 문제점이 무엇인지
2. **Object Pool Pattern**을 배우는 이유가 무엇인지
3. **Object Pool Pattern**을 구현하기 위해서  **최적의 자료구조 선택**은?

---
## 1. Instantiate 함수

> 객체를 생성해주는 함수

### Instantiate 함수 내부에서 일어나는 일

1. **메모리 할당 및 직렬화 해제**
	- 메모리 할당 
2. **역직렬화**
3. **리플렉션 비용발생**
4. **드로우콜 부담**

### Instantiate 함수가 Object Pool 보다 느린 이유
1. 데이터 전송 (HDD / SDD -> RAM -> VRAM)

	- 전송 해야될 데이터가 크면 클수록 CPU 부담 발생 -> 게임이 렉걸림

2. 셰이더 컴파일

---
## 2. Object Pooling

> 미리 생성된 객체를 필요할 때 꺼내고 / 넣고 쓰는 방식

1. 화면에 필요한 양만큼 미리 오브젝트를 메모리에 적재해서 사용

2. 객체 파괴 개신 -> SetActive를 사용
	👉메모리 할당 / 해제 막고 GC 발생 원천 차단
	
3. 메모리 점유율을 일정하게 유지 


### 장점

>CPU & RAM 최적화

- **생성 / 삭제** 연산 횟수 최소화
	-> 재사용성의 장점(오브젝트  ON / OFF)
	-> 매 프레임 게임 안정성 유지, GC렉 방지
### 메모리 관점에서 이득

- **메모리 단편화**
	- 빈번한 할당 / 해제는 메모리 공간을 잘게 쪼개어 큰 데이터를 올릴 공간이 부족하게 만든다.
- **GC 호출 최소화**
	- Destory 함수 호출

---

## 3. 오브젝트 풀 실전 사례
### 1. 오디오
- **사용 사례** : 피격음, 총 발사, 타격음
### 2. 파티클
- **사용 사례** : 피격 이펙트, 트레일(궤적)
### Q. 언제 풀링을 사용하지 말아야 할까?

- 씬에 객체 개수가 그렇게 많지 않다면 + 빈번한 생성 / 파괴가 일어나지 않는다면

---
## 4. Odject Pool 어떤 자료 구조 사용 할것인지?
- **List**
- **Stack**
- **Queue**
- **Dictionary**
- HashSet
- Arrray
- LinkedList

### 1. List
- 순서
- 인덱스로 접근 가능
- 데이터 삭제시 당겨오는 비용 발생
### 2. Stack
- **특징** : 후입순출(LIFO)
- 메모리 캐시 효율이 좋다
- **사용 사례** : 
### 3. Queue
- **특징** : 선입선출(FIFO)
- 안정성이 좋다
- **사용 사례** : 빈번하게 생성 해야 하는 오브젝트트
### 4. Dictionary
- **특징** : 키(Key) 로 값(Value)찾기
- 메모리를 다소 많이 먹음

```csharp
Dictionrary<Enum, Queue<GameObject>>
Dictionrary<Enum, Stack<GameObject>>
```