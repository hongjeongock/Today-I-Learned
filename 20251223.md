# 클래스와 Static

## static 키워드의 기본 개념과 필요성
 - static 키워드는 클래스 내부의 함수나 변수를 메인 함수에서 호출하거나 선언할 때 사용됨, 프로그램이 종료될 때까지 메모리에서 해제되지 않고 고정된 영역을 차지함 (정적 메모리 할당)

 - 동적 메모리(프로그램 실행 중 위치가 바뀌는 참조 타입)와 달리, static은 프로그램 종료 시까지 한 공간을 고정적으로 점유함 => 정적 개념이 존재하기 때문에 동적 개념도 구분됨

## static의 활용 예시와 특징
 - 게임 내 누적 점수처럼 프로그램이 종료될 때까지 변하지 않아야 하는 데이터에 static을 사용함 => 장면이 바뀌어도 값이 유지됨

 - 단순 변수뿐 아니라 클래스, 참조 타입, 메서드에도 static 선언 가능, 정적 메서드는 프로그램 내 어디서든 간편하게 호출 가능함

## static 사용 시 주의사항, 한계
 - static으로 선언된 요소는 프로그램 종료 시까지 메모리에 상주함 => 필요 이상으로 static을 남발하면 불필요한 메모리 낭비 발생
 - static은 편리하지만 잘못 사용하면 프로그램 효율성 저하 및 관리 어려움 초래함. 강한 힘에는 강한 책임이 따름


## static 키워드와 정적 메모리 관리

- 값 타입과 참조 타입의 메모리 할당 및 해제 원리
    - 값 타입과 참조 타입은 명시적으로 변수를 선언하거나 인스턴스를 생성할 때 메모리에 할당됨, 값 타입은 블록 범위 종료 시, 참조 타입은 더 이상 사용되지 않을 때 자동으로 해제됨 (가비지 컬렉션 등)
     - 특별한 상황이 아니라면 두 타입 모두 사용이 끝나면 메모리에서 해제됨, 이는 프로그래밍의 기본적인 메모리 관리 원리임

- static 키워드의 메모리 할당 특성과 전역 접근성
    - static으로 선언된 데이터는 최초 호출 시 데이터 영역에 할당됨 => 프로그램 종료 전까지 자동 해제되지 않음, 전역적으로 접근 가능함
    - 프로그램 관리 등 중추적 데이터나 편리한 참조, 호출을 위해 static 사용됨

- C# 내장 기능에서의 static 활용
    - C#의 메인 함수와 Console 클래스, WriteLine 메서드 등은 모두 static으로 선언되어 있음, F11로 선언 위치 확인 가능
    - static 클래스는 인스턴스 생성 불가 => 정적 변수 및 메서드만 가질 수 있음, 메모리에 항상 상주하므로 중복 생성 불필요

- 정적 생성자와 정적 클래스의 호출 시점
    - 정적 생성자는 static 변수나 메서드가 최초 호출될 때 1회만 실행됨, 일반 생성자와 달리 static 클래스에는 static 생성자만 존재 가능함
    - 정적 생성자에서 일반 변수 초기화 시 에러 발생, static 클래스 내 static 메서드에서 다른 static 변수 호출 가능함
     - static 생성자는 해당 클래스의 인스턴스 생성 또는 static 멤버 접근 시 최초 1회만 호출됨, 호출 시점 이해가 중요


## 키워드의 동작 원리, 생성자 활용법

- 스태틱 키워드의 장점과 주의점, 코드 유지보수 영향
    - 스태틱 멤버는 최초 호출 시점부터 메모리에 상주하게 되어 불필요한 메모리 점유 요소가 될 수 있음, 편리함에 의존해 과도하게 사용하면 객체 간 관계가 모호해지고 유지보수 시 연관 코드 대량 수정 필요 (코드 의존성 증가)

- 스태틱 생성자와 일반 생성자의 차이, 호출 시점
     - 스태틱 생성자는 클래스의 데이터를 처음 다룰 때 1회만 호출됨=> 일반 생성자와 달리 인스턴스 생성과 무관하게 동작 (클래스 단위 초기화 용도)
    - 스태틱 생성자 문법 및 사용법을 코드로 직접 확인 예정, 문법적 이해가 이번 강의 목표임

- 스태틱 필드와 인스턴스 필드의 차이, 접근 방식
    - 일반 필드는 인스턴스 생성 후 참조를 통해 접근해야 하며, new 할당 없이 접근 시 null reference exception 발생 (유효 메모리 주소 없음)
    - 스태틱 키워드가 붙은 변수는 프로그램 전역에서 클래스명만으로 접근 가능. 참조(인스턴스) 불필요, 전역적 데이터 공유 용이


## 게임 개발에서 static 키워드의 올바른 활용

- 스태틱 변수의 장점과 함정, 그리고 메모리 상주 문제
    - 스태틱 변수는 프로그램 어디서나 참조 없이 쉽게 접근 가능하여 사용이 매우 편리해 보임 (플레이어 체력 등 전역 데이터 접근 가능)
    - 하지만 스태틱 변수는 프로그램 종료 시까지 메모리에 계속 남아있음 => 플레이어가 사라져도 메모리 점유 (메인 타이틀, 결과창 등에서도 해제되지 않음)
    - 무분별한 스태틱 사용하면 불필요한 메모리 낭비로 이어짐. 필요 없는 상황에서도 메모리 상주

- 스태틱 변수의 적절한 사용 사례와 객체지향적 관점
    - 게임 내에서 반드시 하나만 존재해야 하고 빈번하게 사용되는 데이터(예: 토탈 스코어, 게임 배속 등)에 스태틱 사용 적합
    - 플레이어 캐릭터는 자주 사용되지만 전역적으로 필요하지 않음. 객체지향적으로는 유저에게만 기능 제공, 다른 객체와 상호작용
    - 스태틱 키워드는 필요할 때만 신중하게 사용해야 하며, 남용 시 오히려 코드 품질 저하 및 메모리 낭비 초래

- 스태틱 함수의 선언 및 활용 방식
    - 스태틱 함수는 객체 인스턴스 없이 클래스 이름만으로 접근 가능하다. 전역적으로 함수 호출 가능
    - 일반 함수는 인스턴스 생성 및 참조 필요, 스태틱 함수는 클래스 단위 접근으로 코드 간결화
    - 인터널 클래스와 스태틱 함수의 차이점은 추후 학습 예정이나, 스태틱 함수는 클래스 이름으로 직접 호출 가능


## static 키워드 활용과 메모리 관리, 변수 접근 방식

- static 함수와 변수의 개념 및 활용 배경
    - static 함수는 클래스 이름으로 직접 접근 가능. 예: Console.WriteLine은 Console 클래스의 static 함수임, 만약 static이 아니었다면 객체 생성 후 접근 필요함
    - 프로그램 내에서 자주 사용되는 기능은 static으로 미리 구성하는 경우 많음. 객체 생성 없이 바로 사용 가능
    - 외부 라이브러리(예: 유니티)에서도 static 함수와 클래스가 다수 존재. 반복적 기능 제공에 적합함 

- static 선언이 메모리에 미치는 영향과 사용 시 주의점
     - static 선언이 메모리에 미치는 영향은 미미함. 작은 단위 추가로 큰 변화 없음 
    - 무분별한 static 사용은 자제 필요함. 자주 쓰는 기능에 한정해 static 사용 권장함 
    - static 변수는 게임 전역 데이터 저장 등 전역적 관리에 유용함(싱글톤 패턴 등에서 활용)

- static 변수와 일반 변수의 접근 방식 및 차이점
    - static 변수는 클래스 이름으로 직접 접근 가능, 일반 변수는 객체(인스턴스) 생성 후 접근해야 함 
    - 클래스 내부에 static 변수와 일반 변수가 함께 있을 때, static 변수는 클래스 기준으로, 일반 변수는 인스턴스 기준으로 접근해야 함

- static 변수의 값 공유 특성과 실전 적용 방법
    - 여러 인스턴스가 생성되어도 static 변수는 하나의 값을 공유. 모든 인스턴스에서 동일한 값 확인 가능함 
    - static 변수의 동작 원리를 코드로 직접 실습하며 체화하는 것이 중요함.


## static 키워드와 클래스 설계, 메모리 할당

- static 변수와 클래스의 메모리 할당 및 값 공유 원리
     - static 변수는 인스턴스가 여러 개 생성되어도 같은 값을 공유함. 프로그램 실행 시 static 관련 클래스나 함수가 먼저 메모리 할당되는 것이 아니라, 처음 호출될 때 할당됨 (지연 할당)
     - static은 클래스 자체에 속하므로 인스턴스 생성 없이 접근 가능함, 하지만 인스턴스 생성이 불필요한 것은 아님 => 변수, 함수, 클래스 모두 static으로 선언 가능 
    - static 멤버는 모든 인스턴스가 동일한 값을 공유함을 디버깅을 통해 확인함 (Study1, Study2, Study3 등) 

- 정적(static)과 동적(dynamic) 메모리 할당의 차이 및 의미
    - 정적 할당은 메모리가 프로그램 실행 전 또는 최초 접근 시 할당되어 유지됨, 값은 자유롭게 변경 가능함 
    - 동적 할당은 프로그램 실행 중에 힙 메모리에 할당되며, 위치가 고정되지 않음 => new 키워드로 인스턴스 생성 시 동적 할당 발생
    - static 키워드가 붙은 참조타입 변수도 데이터 영역에 할당되지만, 동작 방식은 일반 참조타입과 다름 

- static 생성자와 일반 생성자의 호출 시점 및 동작 방식
    - static 생성자는 인스턴스 생성과 무관하게 static 필드나 함수에 처음 접근할 때 한 번만 호출됨 => 여러 인스턴스를 생성해도 static 생성자는 한 번만 호출됨
    - 일반 생성자는 인스턴스 생성 시마다 호출되며, static 생성자보다 나중에 실행됨 (static 생성자 => 일반 생성자 순)
    - static 생성자에서는 static 멤버만 접근 가능하고, 인스턴스 멤버에는 접근 불가 (컴파일 에러 발생) 

- static 클래스의 제약과 활용 목적, 실전 예시
    - static 클래스로 선언하면 내부 필드와 메서드도 모두 static이어야 하며, 인스턴스 생성 불가 => 기능 단위(유틸리티 등)로 사용 
    - 자주 사용하는 기능(예: 넓이 계산, 거리 판별 등)을 static 클래스로 미리 구현해두고 필요할 때마다 바로 사용 가능함 
    - static은 너무 빈번하게 사용하면 오히려 코드 품질 저하 우려, 꼭 필요한 경우에만 사용 권장 

# 상속
## 객체지향 4대 특성
 - 캡슐화 : 프로그램 내에서 객체가 구동되기 위한 데이터(필드)와 동작(메서드)을 객체 자신이 가질 수 있는 성질. 불필욯란 데이터의 변질을 막기 위해 내부의 데이터와 동작을 감추고 외부에는 필요한 부분만 노출(은닉)

 - 상속 : 코드 중복 최소화 및 유지보수성 향상 가능. 공통 속성(이동속도 등)을 부모 클래스에 두고, 자식 클래스에서 상속받아 사용함

 - 다형성 : 상속 구조를 통해 여러 객체를 하나의 타입으로 다룰 수 있음

 - 추상화 : 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질.

## 상속의 개념
 - 상속은 객체지향 프로그래밍의 핵심 특징 중 하나로, 공통점을 묶어 부모(베이스) 클래스로 정의, 자식(파생) 클래스에서 상속받아 중복 코드가 줄어들고, 유지보수 용이

 - 상속 구조에서는 부모 클래스가 선택적으로 공개한 데이터(필드, 메서드)를 자식 클래스가 자유롭게 활용 가능함

 - 접근 제한자(public, private, protected) 중 protected는 상속관계에서만 데이터 접근/수정 가능.

## 상속 적용 전후의 코드 비교 및 설계상의 이점
 - 상속 없이 Bus, Truck 등 개별 클래스 선언 시 공통 속성(속도 등) 반복 구현 필요하다. 이동수단 종류가 많아질수록 코드 중복 심화

 - 상속 구조로 Car(부모) 클래스 선언, Bus/Truck(자식) 클래스에서 상속받아 공통 속성 및 메서드 활용 => 코드 간결화, 유지보수 용이

 - 상속관계에서 동일 변수명 사용 시 base(부모), dis(자식) 키워드로 구분 가능

## 상속과 다형성의 장점
 - 부모 클래스 타입(Car)으로 자식 객체(Bus, Truck) 생성 가능함. 상속받은 객체들을 상위 타입으로 묶어 관리 가능(다형성의 기초)

 - 게임 아이템(무기, 포션, 갑옷 등)을 Item이라는 상위 타입으로 묶어 배열 등으로 일괄 관리 가능 => 코드 재사용성 및 확장성 증가

 - 상속 구조 도입 시 클래스 내부 코드가 간결해지고, 중복 코드 작성 불필요. 유지보수 및 확장에 유리함

## 필드 접근제어자와 생성자 초기화 방식
 - 출시년도(public), 이름(private), 속도(protected) 등 다양한 접근제어자로 필드를 선언함 => 각각의 접근 범위에 따라 외부, 내부, 상속관계에서 접근 가능 여부가 달라짐 (public: 외부 접근 가능, private: 내부만, protected: 상속관계까지)

 - 필드가 많아질 경우 자식 클래스에서 일일이 초기화할 필요 없이 부모(Base) 클래스의 생성자를 통해 한 번에 초기화 가능함. 생성자에서 데이터 초기화 후 자식 클래스는 base 키워드로 부모 생성자 호출

 - 생성자 호출 순서는 자식 => 부모 순서로 호출되며, 실제 실행은 부모 생성자 로직이 먼저 실행됨 => 콘솔 출력으로 확인 가능 (자동차 생성 => 버스 생성 순)

## 상속 구조에서 코드 유지보수의 장점
 - private 필드는 자식 클래스에서 직접 접근 불가하지만, 부모 생성자를 통해 간접적으로 초기화 가능함 => 실제 데이터 변경은 부모 생성자에서 이루어짐

 - 공통 기능(예: 이동 기능) 수정 시 상속 구조를 활용하면 부모 클래스만 수정하면 되어 코드 유지보수성이 크게 향상됨 => 상속 미사용 시 모든 자식 클래스에서 일일이 수정 필요

 - 상속 구조를 잘 활용하면 코드의 가독성과 유연성이 높아지며, 반복적인 코드 작업을 줄일 수 있음. 프로그램 구조가 더 체계적으로 관리됨

## 몬스터 예시
 - 여러 몬스터(고블린, 슬라임, 발록 등)가 공통적으로 가질 수 있는 필드(이름, 속도, 공격력 등)와 메서드(어택 등)를 부모 클래스(Monster)로 정의함

 - 각 몬스터 클래스는 Monster 클래스를 상속받아 공통 기능을 자동으로 사용 가능함 => 추가 기능(예: 발록의 포효)은 자식 클래스에서 별도 구현 가능

 - 상속을 통해 자식 클래스가 부모 클래스의 공개된 기능을 그대로 사용할 수 있으며, 실제로 고블린이 어택 메서드를 별도 선언 없이 사용 가능함을 출력 결과로 확인함

## 상속 구조의 장점과 코드 유지보수의 효율성
 - 공통 속성을 상속 구조로 관리하면 각 클래스마다 일일이 수정할 필요 없이 상위 클래스만 변경하면 됨 => 코드 유지보수 효율증가 (공통 속성 변경 시 반복 작업 줄어듦)

 - 필요에 따라 하위 클래스에서 고유 기능을 선언할 수 있으며, 생성자에서 직접 필드 값을 지정하는 것도 가능함 (상속 구조의 유연성 강조)

## 접근제어자(Public, Private, Protected)의 차이점
 - 필드를 public에서 private으로 변경하면 하위 객체에서 접근 불가 => 에러 발생 (접근제어자 변경 시 영향 주의)

 - 외부에는 노출하지 않으면서 상속관계에서는 접근 가능하게 하려면 protected 사용 => 상속받은 객체 내부에서만 활용 가능

 - 프로퍼티에도 protected 적용 가능, 값의 할당·변경을 상속받은 객체에서만 허용하는 등 세밀한 접근 제어 가능

## 생성자 접근제어와 상속에서의 생성자 호출 흐름
 - 상위 클래스(몬스터)의 생성자를 public으로 두면 직접 인스턴스 생성 가능 => 사용 목적에 맞지 않을 수 있음 (직접 생성 방지 필요)

 - 생성자를 private으로 하면 상속받은 하위 클래스에서도 생성자 호출 불가 => 상속 구조에서 에러 발생 (private 생성자 한계)

 - 생성자를 protected로 지정하면 상속관계에서만 생성자 호출 가능 => 직접 인스턴스 생성 방지, 상속 구조 유지 가능

## 상속관계에서 생성자 인자 전달 및 호출 순서
 - 상위 생성자가 인자를 받으면 하위 클래스 생성자에서 동일하게 인자를 받아 base(상위 생성자)로 전달해야 함 => 에러 방지 및 올바른 초기화

 - 상속관계에서 생성자 호출 순서는 부모 생성자가 먼저 호출되고, 이후 자식 생성자가 호출됨 => 객체 초기화 과정 이해 필요


## 상속관계에서 생성자 호출 순서와 개념적 이해
 - 상위 객체(부모 클래스)의 생성자가 하위 객체(자식 클래스) 생성자보다 먼저 호출됨 => 상속관계에서 생성자 호출 순서를 학습해야 의도치 않은 에러 방지 가능 (상위 객체=부모 객체, 하위 객체=자식 객체로도 표현함)

 - 부모 객체에서 공통 속성(수치 등)을 먼저 초기화할 필요가 있을 때, 하위 객체에서 필요한 정보를 넘겨주며 초기화하는 방식이 자주 사용됨 => 생성자 호출 순서가 중요한 이유임

## 접근 제한자와 상속관계에서의 생성자 활용
 - 접근 제한자(public, protected 등)가 올바르게 설정되어 있는지 확인 필요함 => 상속관계에서 생성자 사용 시 접근 제한자 오류 발생 가능성 있음

 - 상위 객체의 생성자를 호출하려면 별도의 방법이 필요하며, 상속을 굳이 써야 하는지에 대한 의문이 있을 수 있음=

## 코드 재사용성과 상위 타입 배열 활용의 장점
 - 같은 몬스터 여러 마리를 다루거나 다양한 몬스터(고블린, 슬라임 등)를 배열에 넣어 일괄적으로 명령을 내릴 수 있음 => 상속을 통해 코드 재사용성과 관리 편리성 증가

 - 상위 타입(몬스터) 배열에 다양한 하위 객체(고블린, 슬라임, 발록 등)를 넣어 일괄 처리 가능 => 게임 개발에서 매우 자주 쓰이는 패턴

## 상속 구조의 확장성과 아이템 등 다양한 적용 사례
 - 상속 구조는 몬스터뿐 아니라 아이템(포션, 스워드 등)에도 적용 가능함 => 아이템이라는 상위 집단으로 묶어 인벤토리 등에서 범용적으로 활용 가능

 - 반복문 등을 활용해 슬라임 등 객체를 무한히 생성하는 것도 가능함(구체적 구현은 별도 질문 필요)

## 타입 변환(캐스팅)과 함수 접근의 한계 및 주의점
 - 상위 타입(몬스터)에 하위 객체(발록 등)를 담았을 때, 상위 타입에 정의되지 않은 함수(say 등)는 직접 호출 불가 => attack은 호출 가능하지만 say는 호출 불가


## 함수 오버로딩의 개념
 - 동일한 함수명을 사용하되 매개변수의 개수나 유형을 다르게 선언 => 다양한 상황에서 하나의 함수명으로 여러 동작 정의 가능 (코드 가독성 상승, 유지보수 용이)

 - main 함수에서 오버로딩된 함수를 호출해 실제로 의도한 대로 동작하는지 확인 => 매개변수에 따라 함수가 다르게 실행됨을 실습으로 검증함

 - 오버로딩을 통해 코드의 일관성과 가독성을 높일 수 있으므로 함수명이 통일되어 여러 상황에 대응 가능

## 함수 오버라이딩과 가상 함수의 원리 및 적용
 - 자식 클래스에서 부모 클래스의 함수를 재정의(오버라이딩)하려면 부모 함수에 virtual, 자식 함수에 override 키워드 사용 => 자식 객체가 자신만의 동작을 구현 가능
 
 - 부모 타입으로 선언된 인스턴스라도 실제 생성된 자식 클래스의 오버라이딩 함수가 호출됨 => 다형성(polymorphism) 실현

 - 상속 관계가 깊어져도(예: Maltese가 Dog를 상속) 가장 하위 클래스의 오버라이딩 함수가 우선 적용됨

## 상속 제한(봉인, Shield) 키워드의 필요성
 - 협업 시 의도치 않은 상속을 막기 위해 클래스나 함수에 shield 키워드 사용 => 특정 클래스나 함수의 상속 자체를 금지 가능

 - shield 키워드 적용 시 자식 클래스에서 해당 함수나 클래스를 상속받으려 하면 에러 발생함으로 실수 방지 및 코드 안정성 증가

 - 팀 단위 개발에서 코드 오용 방지 및 설계 의도 명확화에 효과적임


## 상속과 업캐스팅, 다운캐스팅의 기본 원리와 활용
 - 상위 클래스(Animal) 타입 배열에 하위 클래스(Dog, Cat) 인스턴스를 담아 다형성을 구현함 => 자식 인스턴스를 부모 타입으로 변환하는 업캐스팅(upcasting) 개념 강조 (상속 구조에서 자주 사용됨)

 - 부모 타입 배열에서 자식 고유 메서드(Barking, Grooming) 호출 시 에러 발생 => 다운캐스팅(downcasting) 필요, is/as 키워드로 안전하게 타입 변환 가능 (is: 캐스팅 가능 여부 반환, as: 성공 시 객체 반환, 실패 시 null 반환)

 - 다운캐스팅 시 조건문과 is/as 키워드 활용 => true일 때만 캐스팅 및 함수 호출, as+null 체크로 간결하게 구현 가능, 예외처리 없이 무작정 캐스팅 시 런타임 에러 발생(InvalidCastException 등) ∵ 타입 불일치

## 오버로딩과 오버라이딩의 차이와 실제 적용 방식
 - 오버로딩: 같은 이름의 메서드(attack 등)를 인자나 반환형만 다르게 여러 번 선언 가능 => 동일 함수명으로 다양한 동작 구현 (함수명 동일, 동작 다름)

 - 오버라이딩: 상위 클래스의 가상함수(virtual)를 하위 클래스에서 override로 재정의 => 배열 등 상위 타입으로 관리해도 실제 인스턴스의 동작(슬라임, 발록 등)이 실행됨

 - 오버로딩/오버라이딩 개념은 신입 개발자 면접에서도 자주 질문되는 핵심 개념임 ∴ 직접 코드로 확인하며 차이점 숙지 필요

## 실드(Sealed) 클래스와 상속 제한의 의도
 - 실드(Sealed) 클래스: 특정 클래스(예: Goblin 등)가 더 이상 상속되지 않도록 봉인 => 설계 의도상 하위 확장 제한, 라이브러리/API 배포 시 오용 방지 목적

 - Protected 생성자 등으로 외부 인스턴스 생성을 제한하고, 실드 키워드로 상속 자체를 차단함 => 코드 의도 명확화 및 오용 방지

## 타입 캐스팅의 안전한 사용법
 - 업캐스팅(암시적): 하위 객체(발록 등)를 상위 타입(몬스터)에 담을 때 자동 형변환 발생 => 데이터 실체는 하위 객체지만 타입 기준으로 상위 메서드만 호출 가능

 - 다운캐스팅(명시적): 상위 타입을 하위 타입으로 변환 시 is/as 키워드로 안전성 확보 => is로 타입 확인 후 as로 캐스팅, 실패 시 null 반환 및 예외 방지

 - 잘못된 캐스팅(예: 슬라임을 발록으로 강제 변환) 시 InvalidCastException 등 런타임 에러 발생 ∵ 타입 불일치, is/as 키워드 사용이 안전함 

# 추상 클래스

## 추상적이라는 개념의 정의와 일상적 사용
- '추상적'이라는 표현은 구체성이 없고, 명확하지 않다는 의미로 일상에서 자주 사용됨 (예: 보고서 내용이 추상적이라는 지적) => 실제로는 두루뭉술하거나 뚜렷하지 않은 상태를 의미함 

- 추상적이라는 말은 구체적이지 않다는 점에서, 명확한 기준이나 세부사항이 부족할 때 사용됨

## 클래스 구현에서의 추상성 적용
- 클래스를 추상적으로 구현한다는 것은 구체적인 내용 없이 뼈대만 제공하는 것임 => 실제 동작은 자식 클래스에서 정의

- 상속 구조에서 베이스 클래스(부모 클래스)는 공통 기능을 묶고, 세부 구현은 파생 클래스에서 담당함 

    (예: 자동차, 몬스터 예시)

## 추상 클래스의 역할과 필요성
 - 부모 클래스가 자식 클래스의 뼈대 역할만 하도록 설계할 수 있음 => 상속만을 위한 구조 제공 
 
    (예: 몬스터 클래스의 뼈대화) 

 - 추상 클래스는 상속과 추상화를 지원하며, 기본 기능과 구조만 제공하고 세부 구현은 자식 클래스에 위임함 

## 코드 안전성과 기존 방법의 한계
 - 스태틱 클래스 선언, 프라이빗 생성자 활용 등으로 인스턴스 생성을 방지함 => 코드 오용 및 협업 시 실수 예방 목적 (클래스 기능 제한, 잘못된 사용 차단) 

 - 이러한 방식에도 불구하고, 코드 유지보수 시 다른 개발자가 의도와 다르게 코드를 사용할 수 있음
 
    (예: 가상 함수 재구현 누락, 인스턴스 생성 실수 등 발생)

## 추상 클래스의 개념과 역할
 - 추상 클래스는 인스턴스 생성 불가. 부모 클래스로서만 사용됨, 필드와 메서드 모두 선언 가능함

 - 추상 메서드는 함수 이름만 선언하고 구현은 하지 않음. 상속받은 클래스에서 반드시 구현해야 함 (가상 함수와의 차이점)

## 컴파일 에러의 장점과 런타임 에러의 단점
 - 가상 함수를 구현하지 않으면 컴파일 에러 발생 => 런타임에서 의도치 않은 결과 방지, 컴파일 단계에서 오류를 미리 확인할 수 있어 디버깅이 쉬워짐 (런타임 에러는 원인 파악이 어려움)

 - 컴파일 에러 발생함으로 프로그래머가 실수로 구현을 누락하거나 잘못 사용할 때 즉시 피드백 가능, 실수 방지에 효과적

## 추상 클래스와 추상 메서드 적용
 - 애니멀 클래스를 추상 클래스(abstract)로 선언 => 반드시 구현해야 하는 규칙(제약) 부여

 - 워크 메서드를 추상 메서드(abstract method)로 변경 시, 함수 내용 작성 시 에러 발생(내용 작성 금지)

 - 함수 내용을 제거하면 에러가 사라짐 => 추상 메서드는 구현 없이 선언만 가능함


## 추상 클래스와 다형성의 핵심 개념

- 추상 클래스와 추상 메서드의 역할 및 구현 강제성
    - 함수 이름만 작성되고 내용이 없는 메서드는 추상 메서드로, 반드시 하위 클래스에서 재구현(오버라이드)해야 함. 재구현하지 않으면 컴파일 단계에서 에러 발생(의도치 않은 결과 방지, 안전장치 역할) 

    - 추상 클래스의 인스턴스는 생성할 수 없으며, 상속받은 클래스에서 추상 메서드를 반드시 구현해야 함 => 미구현 시 컴파일 에러 발생 

    - 추상 메서드는 이름만 선언하고 세미콜론으로 마무리, 실제 구현은 하위 클래스에서 담당함 

## 실제 코드 예시
 - 메인 함수에서 애니멀 타입으로 베어를 선언, 독과 휴먼 인스턴스를 생성해 업캐스팅 후 메서드 호출 => 의도한 결과 도출

 - 추상 클래스는 인스턴스 생성 불가, 베이스(뼈대) 역할만 담당하며 세부 구현은 하위 클래스에서 진행

## 객체지향 다형성과 추상화의 본질
 - 동일한 함수명(예: 스킬)이라도 각 하위 클래스(고블린, 슬라임, 발록 등)에서 다른 동작을 하도록 구현 => 객체지향 다형성의 핵심 

 - 필요한 기능만 간소화해 추상화함, 추상화와 다형성의 활용 정도는 개발자마다 다르나 적극적으로 사용하면 클린 코드에 기여 

## 추상 클래스 및 상속 구조 설계 시 주의점
 - 상속 구조를 과도하게 깊게 설계(서브 몬스터, 서브 서브 몬스터 등)하는 것은 지양해야 하며, 남용 시 오히려 코드가 복잡해지고 더러워질 수 있음

 - 추상 클래스는 다른 객체가 상속받을 뼈대로만 사용, 특별한 사용법 없이 일반 클래스와 동일하게 활용 가능함 

