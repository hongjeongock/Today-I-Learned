# 객체지향 프로그래밍과 C# 언어 심화 정리

## 객체지향 프로그래밍이란?

객체지향 프로그래밍은 프로그램을 기능 단위가 아닌 객체 단위로 구성하는 방식이다.  
객체는 자신이 필요한 데이터(속성)와 동작(기능)을 함께 가지며, 각 객체가 역할을 나누어 프로그램을 구성한다.

이 방식은 다음과 같은 장점을 가진다.

- 코드 구조가 명확해진다.
- 유지보수와 확장이 용이하다.
- 현실 세계의 개념을 코드로 표현하기 쉽다.

---

### 클래스와 객체

C#에서 객체지향의 기본 단위는 `class`이다.  
클래스는 객체를 만들기 위한 설계도 이며, `new` 키워드를 통해 인스턴스를 생성한다.


```csharp
class Car
{
    public int Speed;

    public void Move()
    {
        Console.WriteLine("자동차가 이동한다.");
    }
}
```
```csharp
Car myCar = new Car();
myCar.Speed = 60;
myCar.Move();
```
C#의 클래스는 참조 타입이다.

따라서 객체를 복사하거나 함수로 전달할 때, 실제 데이터가 아닌 메모리 주소가 전달된다.

### 캡슐화와 프로퍼티

캡슐화는 객체 내부의 데이터를 외부에서 직접 접근하지 못하도록 보호하고, 필요한 기능만 외부에 공개하는 객체지향의 핵심 개념이다.

C#에서는 접근 제한자(private, public)와 프로퍼티(Property)를 통해 캡슐화를 구현한다.

```csharp
public class Player
{
    private int hp;

    public int HP
    {
        get { return hp; }
        private set { hp = value; }
    }
}
```
- 프로퍼티를 사용하면..

    - 외부에서는 변수처럼 접근할 수 있어 가독성이 좋다.

    - 내부적으로 데이터 보호 및 제어가 가능하다.

    - 값 변경 시 검증 로직을 추가할 수 있다.

### 상속과 다형성
`상속`은 기존 클래스의 기능을 재사용하여 새로운 클래스를 만드는 방식이다.

중복 코드를 줄이고 공통 기능을 효율적으로 관리할 수 있다.

```csharp
class Vehicle
{
    public void Move()
    {
        Console.WriteLine("이동한다.");
    }
}

class Car : Vehicle
{
}

```
`다형성`은 부모 타입의 변수로 자식 객체를 다룰 수 있는 성질이다.

```csharp
Vehicle vehicle = new Car();
vehicle.Move();
```
이를 통해 코드의 유연성이 크게 향상 되며, 확장에 강한 구조를 만들 수 있다.

### 값 타입과 참조 타입
타입은 값 타입(Value Type)과 참조 타입(Reference Type)으로 나뉜다.

- 값 타입: int, float, struct

    실제 값이 복사된다.

    서로 영향을 주지 않는다.

- 참조 타입: class, array

    메모리 주소가 복사된다.

    여러 변수가 같은 객체를 참조할 수 있다.

### 메모리 구조와 객체
프로그램의 메모리는 크게 다음 영역으로 나뉜다.

- Stack: 지역 변수, 매개변수

- Heap: new로 생성된 객체

- Data: static 변수

- Code: 실행 코드

클래스 인스턴스는 힙(Heap)에 생성되며, 변수에는 해당 객체의 주소가 저장된다.

### 생성자
생성자는 객체가 생성될 때 자동으로 한 번 호출되는 함수이다.

주로 객체의 초기 상태를 설정하는 데 사용된다.

```csharp
class Player
{
    public int Level;

    public Player(int level)
    {
        Level = level;
    }
}
```
생성자를 활용하면 객체 생성과 동시에 안정적인 초기화를 보장할 수 있다.

### Static 키워드

static으로 선언된 변수나 메서드는 객체(인스턴스)에 속하지 않고 클래스 자체에 속한다는 특징을 가진다.  

이 때문에 인스턴스를 생성하지 않아도 클래스 이름만으로 접근할 수 있다.

```csharp
class GameManager
{
    public static int TotalScore;
}
```
```csharp
GameManager.TotalScore = 100;
```
static 멤버는 프로그램 실행 중 최초 접근 시 메모리에 할당되며, 프로그램이 종료될 때까지 해제되지 않는다.

이 특성 때문에 static은 편리하지만, 사용 시 주의가 필요하다

### static과 메모리 구조
- 인스턴스 멤버

    new 키워드로 객체 생성 시 힙(Heap)에 할당

    객체가 더 이상 사용되지 않으면 가비지 컬렉터(GC)에 의해 해제

- static 멤버

    데이터 영역(Data 영역)에 할당

    프로그램 종료 시까지 메모리에 상주

이 차이로 인해 static 변수는 여러 객체가 생성되더라도 하나의 값을 공유하게 된다.

### static 변수와 인스턴스 변수의 차이
static 변수와 인스턴스 변수의 가장 큰 차이는 값의 소유 주체에 있다.
```csharp
class Study
{
    public static int StaticValue;
    public int InstanceValue;
}

```

`staticBalue` : 클래스에 하나만 존재, 모든 인스턴스가 동일한 값을 공유

`InstanceValue` : 인스턴스마다 개별적으로 존재, 객체마다 서로 다른 값을 가질 수 있다.

### static 생성자
static 생성자는 일반 생성자와 달리 클래스가 처음 사용될 때 단 한 번만 호출된다.
```csharp
class Config
{
    static Config()
    {
        Console.WriteLine("static 생성자 호출");
    }
}
```
static 생성자는..

인스턴스 생성 여부와 무관하게 실행됨, 한 번만 호출됨, static 멤버만 초기화 가능, 접근 제한자를 가질 수 없음

클래스 단위의 초기화가 필요할 때 static 생성자는 매우 유용한 도구가 된다.

### static 클래스의 활용
static 클래스로 선언된 클래스는 인스턴스 생성이 불가능하며, 모든 멤버가 static이어야 한다.

```csharp
static class MathUtil
{
    public static int Add(int a, int b)
    {
        return a + b;
    }
}
```
static 클래스는..

전역으로 자수 사용되는 기능, 상태를 가지지 않는 유틸리티 함수, 객체 생성이 불필요한 기능 모음

예 : `console`,`math`

## 상속

객체지향 프로그래밍의 4대 특성에는 캡슐화, 상속, 다형성, 추상화가 있다.  

그중 상속은 코드 구조를 단순화하고, 다형성을 가능하게 만드는 핵심적인 역할을 한다.

상속을 사용하면 여러 클래스가 공통적으로 사용하는 속성과 기능을 부모(베이스)클래스에 정의하고, 자식(파생) 클래스에서는 이를 재사용할 수 있다.

이를 통해 코드 중복을 줄이고, 유지보수성과 확장성을 크게 향상시킬 수 있다.


상속을 사용하지 않는 경우, Bus, Truck 등 이동 수단 클래스마다  
속도나 이동 기능을 반복해서 구현해야 한다.

반면 상속 구조를 사용하면 다음과 같이 설계할 수 있다.

```csharp
class Car
{
    protected int speed;

    public void Move()
    {
        Console.WriteLine("이동 중");
    }
}

class Bus : Car
{
}

class Truck : Car
{
}
```
### 제한자와 상속

상속 구조에서 접근 제한자는 매우 중요한 역할을 한다.

`public` : 외부, 내부, 상속 관계 모두 접근 가능

`private` : 해당 클래스 내부에서만 접근 가능

`protected` : 외부에서는 접근 불가, 상속 관계에서는 접근 가능

### 상속과 생성자 호출 순서
상속 관계에서 객체가 생성될 때 부모 클래스의 생성자가 먼저 호출되고, 그 다음 자식 클래스의 생성자가 호출된다.

부모 생성자를 통해 공통 필드를 초기화하면 자식 클래스에서는 불필요한 중복 초기화를 피할 수 있다.

생성자의 접근 제한자를 protected로 설정하면 외부에서 직접 인스턴스 생성을 막으면서
상속 구조는 유지할 수 있다.
```csharp
class Monster
{
    protected string name;

    protected Monster(string name)
    {
        this.name = name;
    }
}

class Goblin : Monster
{
    public Goblin(string name) : base(name)
    {
    }
}

```
### 오버로딩과 오버라이딩
- 오버로딩 : 같은 메서드 이름, 매개변수 개수 또는 타입이 다름.

    코드 가독성을 높이고 하나의 개념을 다양한 방식으로 표현할 수 있게 해준다.

- 오버라이딩 : 부모 클래스의 메서드를 자식 클래스에서 재정의하는 방식, 부모 타입으로 객체를 다루더라도 실제 생성된 자식 객체의 메서드가 실행된다.

### 업캐스팅, 다운캐스팅
- 업캐스팅 : 자식 -> 부모, 암시적 변환, 안전함

- 다운캐스팅 : 부모 -> 자식, 명시적 변환 필요, 주의 필요
```csharp
if (monster is Goblin goblin)
{
    goblin.SpecialAttack();
}
```
is, as 키워드를 사용하면 런타임 에러 없이 안전하게 캐스팅할 수 있다.


### sealed
클래스나 메서드의 상속을 금지할 때 사용된다.
```csharp
sealed class Goblin
{
}
```
의도하지 않은 확장을 막는 데 매우 유용

